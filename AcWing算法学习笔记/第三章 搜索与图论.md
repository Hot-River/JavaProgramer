图论侧重于实现，难点在于建图

### DFS与BFS

深度优先搜索 与 宽度优先搜索

![1620473765817](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620473765817.png)

凡是算法思路比较奇怪、对空间要求比较高的用DFS来做

凡是求最短的最小的都用BFS来做，前提是边的权重都是1

DFS重要是的思路

DFS回溯时要注意恢复状态

BFS用队列实现

BFS在权重为1时，每个首次被访问的点离出发点的距离都是最短的

### 树和图的存储

树是无环连通 图

有向图：

​	存储：

​		邻接矩阵：用的比较少，比较费空间，适合稠密图

​		邻接表：每个结点指向一个链表，表示从该节点能到达的结点

### 树与图的深度优先遍历

写代码时，最好以一个点为例去写

### 树与图的宽度优先遍历

队列模拟

### 拓扑序列

针对有向图，有环一定不存在拓扑序列

有向无环图（DAG拓扑图）一定存在拓扑序列

图的宽度优先遍历

入度为0的点即可作为起点

![1620482644203](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620482644203.png)

答案可能不唯一

## 最短路

根据题目要求选择算法，即题目给的数据范围

难点在于建图，将问题抽象成图（点和边）

![1620729861502](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620729861502.png)

### 单源最短路

Dijkstra算法要求一定不存在负边

1、所有边权都是正数（Dijkstra算法基于贪心）	

**朴素Dijkstra算法**：时间复杂度O(n^2)。适用于稠密图，图用邻接矩阵存储，有向图和无向图做法是一样的			

①初始化距离

②循环迭代

s:当前已确定最短距离的点

​		找到不在s中的距离最近的点

​		用其来更新其他点的距离

​		将其加入s中		

每次循环都能确定一个点的最短距离	

![1620730715240](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620730715240.png)

**堆优化版Dijksra算法**：时间复杂度O(mlogn)，适用于稀疏图

堆用优先权队列来实现

2、存在负权边	

99.9%的题目不存在负环

**Bellman-Fold算法**：时间复杂度O(mn)	（基于离散数学）

**适用条件&范围：**

​		单源最短路径(从源点s到其它所有顶点v);

​		有向图&无向图(无向图可以看作(u,v),(v,u)同属于边集E的有向图);

​		边权可正可负(如有负权回路输出错误提示);

​		差分约束系统;

​		有边数限制的最短路问题

**Bellman-Ford算法的流程如下：**

​		给定图G(V, E)（其中V、E分别为图G的顶点集与边集），源点s，数组Distant[i]记录从源点s到顶点i的路径长度，初始化数组Distant[n]为, Distant[s]为0；

​		以下操作循环执行至多n-1次，n为顶点数：
​		对于每一条边e(u, v)，如果Distant[u] + w(u, v) < Distant[v]，则令Distant[v] = Distant[u]+w(u, v)。w(u, v)为边e(u,v)的权值；
​		若上述操作没有对Distant进行更新，说明最短路径已经查找完毕，或者部分点不可达，跳出循环。否则执行下次循环；

​		为了检测图中是否存在负环路，即权值之和小于0的环路。对于每一条边e(u, v)，如果存在Distant[u] + w(u, v) < Distant[v]的边，则图中存在负环路，即是说改图无法求出单源最短路径。否则数组Distant[n]中记录的就是源点s到各顶点的最短路径长度。

​	可知，Bellman-Ford算法寻找单源最短路径的时间复杂度为O(V*E).

**Bellman－Ford算法可以大致分为三个部分**
		第一，初始化所有点。每一个点保存一个值，表示从原点到达这个点的距离，将原点的值设为0，其它的点的值设为无穷大（表示不可达）。
		第二，进行循环，循环下标为从1到n－1（n等于图中点的个数）。在循环内部，遍历所有的边，进行松弛计算。
		第三，遍历途中所有的边（edge（u，v）），判断是否存在这样情况：d（v） > d (u) + w(u,v)，则返回false，表示途中存在从源点可达的权为负的回路。 

有负权回路，则最短路不一定存在，如果负环不在最短路径中，则没有影响

迭代k次表示经过不超过k条边的最短路的距离

如果迭代n次依然有更新，则说明存在一条最短路径有n条边，即有n+1条边，根据抽屉原理，一定存在负环。

![1620737908952](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620737908952.png)

**SPFA算法**：一般时间复杂度O(m)、最坏时间复杂度O(mn)

要求图中一定不含负环，但可以用来求负环	

对bellman-ford算法的优化，一般情况下都优于Bellman-Ford算法

spfa也能解决权值为正的图的最短距离问题，且一般情况下比Dijkstra算法还好

Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。

**spfa算法步骤**
	queue <– 1
	while queue 不为空
		 (1) t <– 队头
			 queue.pop()
		 (2)用 t 更新所有出边 t –> b，权值为w
			 queue <– b (若该点被更新过，则拿该点更新其他点)

![1620739959904](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620739959904.png)

SPFA算法判负环

![1620740838294](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620740838294.png)

### 多源汇最短路	

**Floyd算法**：时间复杂度O(n^3)	（基于动态规划）

算法思想csdn了解一下

用邻接矩阵存储图

![1620741774072](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620741774072.png)

## 最小生成树

对应的图都是无向图

![1620959159539](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620959159539.png)

### Prim算法

朴素版Prim算法 ：稠密图 O(n^2)		![1620959514131](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620959514131.png)

堆优化版Prim算法：稀疏图  O(mlogn) 一般不常用

### Kruskal算法

时间复杂度：O(mlogm）稀疏图

![1620961302018](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620961302018.png)

## 二分图

![1620959172851](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620959172851.png)

### 染色法

时间复杂度O(n + m)

判断一个图是不是二分图

一个图是二分图当且仅当图中不含奇数环（环中边的条数是奇数）

一般基于深度优先遍历实现

![1620991557823](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620991557823.png) 

### 匈牙利算法

时间复杂度：最坏O(mn)，实际运行时间一般远小于O(mn)

匹配：在图论中，一个「匹配」是一个边的集合，其中任意两条边都没有公共顶点。

最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。

![1620992870821](C:\Users\艾虎\AppData\Roaming\Typora\typora-user-images\1620992870821.png)

